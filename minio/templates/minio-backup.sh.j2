#!/bin/bash
# MinIO Backup Script
# Generated by Ansible - Do not edit manually

set -euo pipefail

# Configuration
MINIO_ALIAS="local"
BACKUP_DIR="{{ minio_backup_dir }}"
RETENTION_DAYS="{{ minio_backup_retention_days }}"
LOG_FILE="/var/log/minio/backup.log"
DATE=$(date +"%Y%m%d_%H%M%S")
BACKUP_NAME="minio_backup_${DATE}"

# MinIO Credentials
export MC_HOST_local="{{ minio_scheme }}://{{ minio_root_user }}:{{ minio_root_password }}@{{ minio_bind_address }}:{{ minio_port }}"

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# Error handling
error_exit() {
    log "ERROR: $1"
    exit 1
}

# Check if MinIO is accessible
check_minio() {
    log "Checking MinIO accessibility..."
    if ! mc admin info local >/dev/null 2>&1; then
        error_exit "MinIO server is not accessible"
    fi
    log "MinIO server is accessible"
}

# Create backup directory
create_backup_dir() {
    local backup_path="${BACKUP_DIR}/${BACKUP_NAME}"
    mkdir -p "$backup_path" || error_exit "Failed to create backup directory: $backup_path"
    echo "$backup_path"
}

# Backup MinIO data
backup_data() {
    local backup_path="$1"
    
    log "Starting MinIO data backup to $backup_path"
    
    # Get list of buckets
    local buckets
    buckets=$(mc ls local/ | awk '{print $5}' | grep -v "^$" || true)
    
    if [ -z "$buckets" ]; then
        log "No buckets found to backup"
        return 0
    fi
    
    # Backup each bucket
    for bucket in $buckets; do
        bucket=$(echo "$bucket" | tr -d '/')
        log "Backing up bucket: $bucket"
        
        # Create bucket directory
        mkdir -p "${backup_path}/buckets/$bucket"
        
        # Mirror bucket contents
        if mc mirror "local/$bucket" "${backup_path}/buckets/$bucket" --overwrite; then
            log "Successfully backed up bucket: $bucket"
        else
            log "WARNING: Failed to backup bucket: $bucket"
        fi
        
        # Backup bucket policy
        if mc policy get "local/$bucket" > "${backup_path}/buckets/${bucket}_policy.json" 2>/dev/null; then
            log "Backed up policy for bucket: $bucket"
        else
            log "WARNING: Failed to backup policy for bucket: $bucket"
        fi
    done
}

# Backup MinIO configuration
backup_config() {
    local backup_path="$1"
    
    log "Backing up MinIO configuration"
    
    # Create config directory
    mkdir -p "${backup_path}/config"
    
    # Backup server info
    mc admin info local > "${backup_path}/config/server_info.txt" 2>/dev/null || true
    
    # Backup service accounts
    mc admin user svcacct list local > "${backup_path}/config/service_accounts.txt" 2>/dev/null || true
    
    # Backup users
    mc admin user list local > "${backup_path}/config/users.txt" 2>/dev/null || true
    
    # Backup policies
    mc admin policy list local > "${backup_path}/config/policies.txt" 2>/dev/null || true
    
    # Backup configuration
    cp -r {{ minio_config_dir }}/* "${backup_path}/config/" 2>/dev/null || true
    
    log "Configuration backup completed"
}

# Create backup manifest
create_manifest() {
    local backup_path="$1"
    
    log "Creating backup manifest"
    
    cat > "${backup_path}/manifest.json" << EOF
{
    "backup_date": "$(date -Iseconds)",
    "backup_name": "$BACKUP_NAME",
    "minio_version": "{{ minio_version }}",
    "server_info": {
        "host": "{{ ansible_default_ipv4.address }}",
        "port": {{ minio_port }},
        "console_port": {{ minio_console_port }}
    },
    "backup_size": "$(du -sh "$backup_path" | cut -f1)",
    "bucket_count": $(find "${backup_path}/buckets" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l || echo 0)
}
EOF
    
    log "Backup manifest created"
}

# Compress backup
compress_backup() {
    local backup_path="$1"
    local compressed_file="${backup_path}.tar.gz"
    
    log "Compressing backup: $compressed_file"
    
    cd "$BACKUP_DIR"
    if tar -czf "${BACKUP_NAME}.tar.gz" "$BACKUP_NAME"; then
        rm -rf "$BACKUP_NAME"
        log "Backup compressed successfully: ${compressed_file}"
    else
        error_exit "Failed to compress backup"
    fi
}

# Clean old backups
cleanup_old_backups() {
    log "Cleaning up backups older than $RETENTION_DAYS days"
    
    find "$BACKUP_DIR" -name "minio_backup_*.tar.gz" -type f -mtime +$RETENTION_DAYS -delete 2>/dev/null || true
    
    # Clean up log files older than retention period
    find /var/log/minio -name "backup.log.*" -type f -mtime +$RETENTION_DAYS -delete 2>/dev/null || true
    
    log "Cleanup completed"
}

# Main backup function
main() {
    log "Starting MinIO backup process"
    
    # Check prerequisites
    command -v mc >/dev/null 2>&1 || error_exit "MinIO client (mc) is not installed"
    
    # Ensure backup directory exists
    mkdir -p "$BACKUP_DIR"
    
    # Check MinIO accessibility
    check_minio
    
    # Create backup
    local backup_path
    backup_path=$(create_backup_dir)
    
    # Perform backup
    backup_data "$backup_path"
    backup_config "$backup_path"
    create_manifest "$backup_path"
    
    # Compress backup
    compress_backup "$backup_path"
    
    # Cleanup old backups
    cleanup_old_backups
    
    log "MinIO backup completed successfully"
    
    # Display backup summary
    log "Backup Summary:"
    log "- Backup file: ${BACKUP_DIR}/${BACKUP_NAME}.tar.gz"
    log "- Backup size: $(du -sh "${BACKUP_DIR}/${BACKUP_NAME}.tar.gz" | cut -f1)"
    log "- Total backups: $(find "$BACKUP_DIR" -name "minio_backup_*.tar.gz" | wc -l)"
}

# Run main function
main "$@"