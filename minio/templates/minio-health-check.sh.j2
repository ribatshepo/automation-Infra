#!/bin/bash
# MinIO Health Check Script
# Generated by Ansible - Do not edit manually

set -euo pipefail

# Configuration
MINIO_HOST="{{ minio_bind_address }}"
MINIO_PORT="{{ minio_port }}"
MINIO_CONSOLE_PORT="{{ minio_console_port }}"
LOG_FILE="/var/log/minio/health-check.log"
ALERT_THRESHOLD=3  # Number of consecutive failures before alert
FAILURE_FILE="/tmp/minio_health_failures"

# MinIO Credentials
export MC_HOST_local="{{ minio_scheme }}://{{ minio_root_user }}:{{ minio_root_password }}@{{ minio_bind_address }}:{{ minio_port }}"

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# Check if port is listening
check_port() {
    local port=$1
    local service_name=$2
    
    if nc -z "$MINIO_HOST" "$port" 2>/dev/null; then
        log "✓ $service_name port $port is accessible"
        return 0
    else
        log "✗ $service_name port $port is not accessible"
        return 1
    fi
}

# Check MinIO server status
check_minio_server() {
    log "Checking MinIO server status..."
    
    # Check if MinIO port is listening
    if ! check_port "$MINIO_PORT" "MinIO Server"; then
        return 1
    fi
    
    # Check if console port is listening
    if ! check_port "$MINIO_CONSOLE_PORT" "MinIO Console"; then
        return 1
    fi
    
    return 0
}

# Check MinIO service health
check_minio_health() {
    log "Checking MinIO service health..."
    
    # Check systemd service status
    if systemctl is-active minio >/dev/null 2>&1; then
        log "✓ MinIO systemd service is active"
    else
        log "✗ MinIO systemd service is not active"
        return 1
    fi
    
    # Check MinIO admin info
    if mc admin info local >/dev/null 2>&1; then
        log "✓ MinIO admin interface is responding"
    else
        log "✗ MinIO admin interface is not responding"
        return 1
    fi
    
    return 0
}

# Check disk space
check_disk_space() {
    log "Checking disk space..."
    
    local data_dir="{{ minio_data_dir }}"
    local backup_dir="{{ minio_backup_dir }}"
    local threshold={{ minio_disk_usage_threshold }}
    
    # Check data directory disk usage
    local data_usage
    data_usage=$(df "$data_dir" | tail -1 | awk '{print $5}' | sed 's/%//')
    
    if [ "$data_usage" -lt "$threshold" ]; then
        log "✓ Data directory disk usage: ${data_usage}% (threshold: ${threshold}%)"
    else
        log "✗ Data directory disk usage: ${data_usage}% (exceeds threshold: ${threshold}%)"
        return 1
    fi
    
    # Check backup directory disk usage
    local backup_usage
    backup_usage=$(df "$backup_dir" | tail -1 | awk '{print $5}' | sed 's/%//')
    
    if [ "$backup_usage" -lt "$threshold" ]; then
        log "✓ Backup directory disk usage: ${backup_usage}% (threshold: ${threshold}%)"
    else
        log "✗ Backup directory disk usage: ${backup_usage}% (exceeds threshold: ${threshold}%)"
        return 1
    fi
    
    return 0
}

# Check MinIO performance
check_minio_performance() {
    log "Checking MinIO performance..."
    
    # Create a test file
    local test_bucket="health-check"
    local test_file="health-check-$(date +%s).txt"
    local test_content="MinIO health check test file - $(date)"
    
    # Create test bucket if it doesn't exist
    mc mb "local/$test_bucket" --ignore-existing >/dev/null 2>&1 || true
    
    # Write test
    if echo "$test_content" | mc pipe "local/$test_bucket/$test_file" >/dev/null 2>&1; then
        log "✓ MinIO write test successful"
    else
        log "✗ MinIO write test failed"
        return 1
    fi
    
    # Read test
    if mc cat "local/$test_bucket/$test_file" >/dev/null 2>&1; then
        log "✓ MinIO read test successful"
    else
        log "✗ MinIO read test failed"
        return 1
    fi
    
    # Cleanup test file
    mc rm "local/$test_bucket/$test_file" >/dev/null 2>&1 || true
    
    return 0
}

# Get failure count
get_failure_count() {
    if [ -f "$FAILURE_FILE" ]; then
        cat "$FAILURE_FILE"
    else
        echo "0"
    fi
}

# Update failure count
update_failure_count() {
    local increment=$1
    local current_count
    current_count=$(get_failure_count)
    
    if [ "$increment" -eq 1 ]; then
        echo $((current_count + 1)) > "$FAILURE_FILE"
    else
        echo "0" > "$FAILURE_FILE"
    fi
}

# Send alert (placeholder for notification system)
send_alert() {
    local message="$1"
    local severity="$2"
    
    log "ALERT [$severity]: $message"
    
    # Add your notification system here (email, Slack, etc.)
    # Example: echo "$message" | mail -s "MinIO Alert" admin@example.com
    
    # Log to syslog
    logger -t minio-health -p user.err "$message"
}

# Main health check function
main() {
    log "Starting MinIO health check"
    
    local failed=0
    
    # Run health checks
    check_minio_server || failed=1
    check_minio_health || failed=1
    check_disk_space || failed=1
    check_minio_performance || failed=1
    
    # Handle results
    if [ "$failed" -eq 0 ]; then
        log "✓ All MinIO health checks passed"
        update_failure_count 0
        exit 0
    else
        log "✗ MinIO health check failed"
        update_failure_count 1
        
        local failure_count
        failure_count=$(get_failure_count)
        
        if [ "$failure_count" -ge "$ALERT_THRESHOLD" ]; then
            send_alert "MinIO health check has failed $failure_count consecutive times" "CRITICAL"
        fi
        
        exit 1
    fi
}

# Run main function
main "$@"